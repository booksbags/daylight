### 模块化

当前端的项目逐渐增大时，为了避免在协同开发的过程中，出现命名冲突，从而导致代码逻辑错误，所以需要模块化。模块化能够使得模块中的代码不会自动暴露到全局环境，创建者根据需要暴露必要的接口给调用者，调用者根据需要手动导入模块中的接口。这样就不会出现不易察觉的命名冲突。

### CommonJS

CommonJS使用js社区提出的模块化方案，仅node实现，浏览器端不支持。CommonJS是同步的动态导入，只有当node执行到require语句时，才会去加载导入的模块。CommonJS规范要求：

1. 如果一个文件具有导出或者导入语句，那么这个文件就是一个模块
2. 模块中的变量不会主动暴露到全局环境
3. 如果一个模块需要暴露接口给外部使用，可以通过exports对象，exports对象是一个空对象，需要暴露的接口作为exports的属性即可
4. 如果想要导入一个模块，可以使用require函数，require函数会根据传入的路径，返回对应的exports对象，require具有缓存功能，同一个模块不会重复导入，只会复用导出的结果，该结果可以修改。

### node的模块查找策略

require函数接收一个字符串表示模块的路径

1. 如果该字符串是相对路径或者绝对路径那么，node会先到相关的目录下，查找该模块是否存在，如果不存在，添加后缀名***.js***, ***.node***, ***.json***等后缀后查看，是否存在，如果存在导入项目模块，如果不存在，看是否存在同名的目录，如果存在进入相关目录查找package.json文件中的main字段，如果存在main字段，导入main字段指定的文件，如果main字段不存在，或者main指定的文件不存在，看是否具有index.js或者index.json文件，如果有就导入这个文件，如果没有报错。
2. 只有模块名称，看是否是内置模块，如果是导入内置模块，否则查看当前目录是否存在node_modules目录，如果存在，进入node_modules目录查找，如果不存在，node_modules目录，或者该目录中没有相关模块，到上一级目录重复上一步，直到根目录。如果根目录都没有找到就报错。

### ESModule

ESModule是官方提供的，通过语法来实现的，浏览器和node都支持。ESModule支持***同步的静态导入***也支持***异步的动态导入***，

ESModule使用import from语句来导入模块，import指定需要导入的接口，form指定导入的模块路径。该路径必须是以***./***, ***../***, ***/***开头的路径，且路径必须写全，

ESModule不会使用node的模块查找策略，只会根据路径来导入模块，如果路径指定的模块不存在，就会报错。

> 在Node环境中，如果导入的模块是node_modules中的模块，那么查找策略遵循node的模块查找策略，可以不用后缀，可以不用相对路径和绝对路径

### 浏览器的处理

1. 为了向后兼容，如果script标签导入的文件是一个模块，那么type属性需要指定为***module***

```html	
<script src="../xx.js" type="module"></script>
```

2. 同步的静态导入要求，导入语句必须位于所有代码之前，但是不遵守也不会报错，浏览器会自动将其提升到最前面。
3. 模块中的代码必须等待静态导入的模块，加载完成并运行以后，才会运行。
4. 每一个模块都是一个js文件，所以浏览器都会发起一次网络请求，获取js文件，如果模块过多，可能会导致浏览器发送大量的网络请求，此时需要构建工具进行代码的构建，减少网络请求的数量。

### typescript中对模块的处理

1. 如果target配置为es3或者es5，编译以后的模块默认为CommonJS，es6以后，编译以后的模块化默认为ESModule，可以通过指定module设置模块化标准。

2. ts不会修改模块的路径，如果编译以后模块化标准为ESModule，那么编译以后的结果是不能直接运行的。需要手动给模块添加后缀.js, 不能是ts，因为ts不会修改导入语句中的模块路径，所以如果加的后缀为***.ts***,编译以后还是***.ts***.

3. typescript的代码可以转换为CommonJS的代码也可以转换为ESModule的代码，所以ts新增了两个module配置，node16，NodNext, 如果module为node16和NodeNext，那么ts既可以转换为CommonJs的代码也可以转换为ESModule的代码，则取决于package.json的type配置，如果没有，默认编译以后的ts模块化使用CommonJs，或者ts模块自身也可以指定编译以后的模块化标准：mts编译以后就是mjs, cts编译以后就是cjs。

   > 如果module指定为node16或者nodeNext,那么模块解析方式（moduleResolution）也必须指定为node16或者nodeNext。导入自定义模块的时候必须填写完整的模块名称。后缀为编译以后的后缀。如果编译以后的代码运行在浏览器环境，那么任何模块都必须使用完整的路径。

4. ts在CommonJS模块化下，查找模块时，策略和node查找模块的策略差不多，只不过补充的后缀为***.ts***, ***.tsx***, ***.d.ts***, 在package.json中需要查找***types***字段来指定如何模块。

### node对模块化的处理

默认情况下,node 认为***.js***文件使用的模块化标准为CommonJS，如果使用的是ESModule,需要再package.json中通过type字段指明，模块化标准，或者通过修改后缀名，***.mjs***,表明该模块使用的是ESModule模块化， ***.cjs***,表明该模块使用的是CommonJS模块化，***.cjs***不能导入***.mjs***,但是***.mjs***可以导入***.cjs***;

文件使用的模块化标准：默认值 < package.json的type字段 < 文件的后缀